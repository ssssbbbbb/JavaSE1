/**
 *  <h1>线程通信的例子：使用两个线程打印 1-100，线程1， 线程2， 交替打印</h1>
 */
public class k_线程的通信 {
    public static void main(String[] args) {
        Number number = new Number();

        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);

        t1.setName("线程一");
        t2.setName("线程二");

        t1.start();
        t2.start();
    }
}
/* =====================================================================================================================
一、拥有线程安全问题 ———— 打印的数值重复了
    解决 ———— 使用同步代码块 synchronized (this){...}

------------------------------------------------------------------------------------------------------------------------
二、新的问题
        线程安全问题虽然解决了，但是运行后发现，run()方法几乎都是线程二在执行，这导致了线程一几乎成了摆设。

    解决方法：使用线程通信
        1、需要用到的方法： ① wait()   使当前线程处于等待状态，直到它被唤醒,并且它会释放锁（同步监视器）让其它的线程进来
                          ② notify()   唤醒在此对象的监视器上等待的单个线程，如果有多个线程，就唤醒优先级最高的那个
        2、步骤：如下Number类
            - 当快的线程执行run()的时候，会先执行notify()，但如果此时没有线程在等待，则notify()就没有任何作用，同时也没有反馈。
            - 接着执行完if分支机构里的代码就来到了wait()处，此方法会让执行它的线程进入等待状态并且释放锁，这样就能让慢的线程有机会拿到
            同步监视器的锁，执行run()方法。
            - 当慢的线程进入run()方法后拿到 synchronized()的锁，就能开始操作共享数据，而此时的快线程还是处于等待状态。当慢线程进入同
            步代码块执行到notify()后，快线程就被唤醒开始继续执行程序，但因为此时拿到锁的是慢线程，因此快线程只能在外面等待，等慢线程操
            作完后才能进入。
            - 而当慢线程执行完共享数据后，也来到了wait()处，因此也进入了等待状态，等待快线程执行notify()方法把它唤醒...
            - 接着就是这样轮流进行等待，然后被对方唤醒。
        3、说明：
            ① wait()、notify()、notifyAll()三个方法必须使用在同步代码块或同步方法中。
            ② wait()、notify()、notifyAll()三个方法的调用者，必须是同步代码块或同步方法中的同步监视器（在这里是this），否则会发生
            异常IllegalMonitorStateException 。
            ③ 这三个方法都是定义在Object类中的。如果拿Object的实例对象做同步监视器，那么就要显式的使用Object的对象来调用这三个方法。

-----------------------------------------------------------------------------------------------------------------------
三、sleep() 和 wait() 的异同
    1、相同点：一旦执行方法，都可以使当前的线程进入阻塞状态。
    2、不同点：① 两个方法的声明位置不一样：Thread类中声明sleep()，Object类中声明wait()。
              ② 调用的范围要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块中
              ③ 关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁
===================================================================================================================== */
class Number implements Runnable {
    private int number = 1;
    //Object object = new Object();
    @Override
    public void run() {

        while (true) {

            synchronized (this) {

                notify();   //如果是要唤醒多个线程，就需要使用 notifyAll()

                if (number <= 100) {
                    System.out.println(Thread.currentThread().getName() + " --:-- " + number);
                    number++;

                    try {
                        wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                } else {
                    break;
                }
            }

        }

    }
}